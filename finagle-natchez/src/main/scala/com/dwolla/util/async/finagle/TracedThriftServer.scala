package com.dwolla.util.async.finagle

import cats.*
import cats.effect.*
import cats.effect.std.{Dispatcher, Env}
import cats.mtl.*
import cats.syntax.all.*
import cats.tagless.aop.*
import cats.tagless.implicits.*
import com.comcast.ip4s.{IpAddress, SocketAddress}
import com.dwolla.util.async.finagle.HigherKindedToMethodPerEndpoint.*
import com.dwolla.util.async.twitter.*
import com.twitter.finagle.*
import com.twitter.finagle.tracing.TraceId
import com.twitter.util.{Future, Promise}
import natchez.*

import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success}

/**
 * Starts a Finagle server that will host the given Thrift
 * method-per-endpoint implementation.
 */
object TracedThriftServer {
  /**
   * Builds a `ListeningServer` with Zipkin and Natchez tracing enabled. The `Thrift[F]` implementation will
   *
   * @param addr       the socket address at which to listen for connections. (Typically `0.0.0.0:port`)
   * @param label      the name to assign the service in the Zipkin traces
   * @param iface      the Thrift method-per-endpoint implementation. Must be implemented in `Kleisli[F, Span[F], *]` so the span continued from Zipkin can be injected into the program.
   * @param entryPoint the Natchez `EntryPoint` responsible for creating `Span` instances based on the Trace IDs coming from Finagle/Zipkin
   * @param ec         `ExecutionContext` where Twitter Futures will be completed when the Scala Future output by `Dispatcher.unsafeToFuture` completes
   * @param LocalSpan  `Local[F, Span[F]]` used to continue or start a new root span when a Thrift request is received
   * @tparam F      the effect in which to operate, which must have `Async[F]` and `Env[F]` instances available
   * @tparam Thrift the higher-kinded MethodPerEndpoint Thrift algebra generated by scrooge and modified by the `AddCatsTaglessInstances` scalafix
   * @return a `Resource[F, ListeningServer]` managing the lifecycle of the underlying Finagle server
   */
  def apply[F[_] : Async : Env, Thrift[_[_]] : HigherKindedToMethodPerEndpoint : Instrument](addr: SocketAddress[IpAddress],
                                                                                             label: String,
                                                                                             iface: Thrift[F],
                                                                                             entryPoint: EntryPoint[F]
                                                                                            )
                                                                                            (implicit ec: ExecutionContext,
                                                                                             LocalSpan: Local[F, Span[F]]): Resource[F, ListeningServer] =
    TracedThriftServer(addr, label, iface, entryPoint, Span.Options.Defaults.withSpanKind(Span.SpanKind.Server))

  /**
   * Builds a `ListeningServer` with Zipkin and Natchez tracing enabled. The `Thrift[F]` implementation will
   *
   * @param addr         the socket address at which to listen for connections. (Typically `0.0.0.0:port`)
   * @param label        the name to assign the service in the Zipkin traces
   * @param iface        the Thrift method-per-endpoint implementation. Must be implemented in `Kleisli[F, Span[F], *]` so the span continued from Zipkin can be injected into the program.
   * @param entryPoint   the Natchez `EntryPoint` responsible for creating `Span` instances based on the Trace IDs coming from Finagle/Zipkin
   * @param spanOptions  allows the caller to set specific Span options that should be set on each new trace
   * @param ec           `ExecutionContext` where Twitter Futures will be completed when the Scala Future output by `Dispatcher.unsafeToFuture` completes
   * @param LocalSpan    `Local[F, Span[F]]` used to continue or start a new root span when a Thrift request is received
   * @tparam F           the effect in which to operate, which must have `Async[F]` and `Env[F]` instances available
   * @tparam Thrift      the higher-kinded MethodPerEndpoint Thrift algebra generated by scrooge and modified by the `AddCatsTaglessInstances` scalafix
   * @return a `Resource[F, ListeningServer]` managing the lifecycle of the underlying Finagle server
   */
  def apply[F[_] : Async : Env, Thrift[_[_]] : HigherKindedToMethodPerEndpoint : Instrument](addr: SocketAddress[IpAddress],
                                                                                             label: String,
                                                                                             iface: Thrift[F],
                                                                                             entryPoint: EntryPoint[F],
                                                                                             spanOptions: Span.Options,
                                                                                            )
                                                                                            (implicit ec: ExecutionContext,
                                                                                             LocalSpan: Local[F, Span[F]]): Resource[F, ListeningServer] =
    Dispatcher.parallel[F]
      .map(new UnsafeInstrumentationToFuture[F, Thrift](_, entryPoint, spanOptions))
      .map(iface.instrument.mapK(_))
      .flatMap(t => Resource.make(acquire(addr, label, t))(release[F]))

  private def currentTraceId(): Future[Option[TraceId]] =
    Future(com.twitter.finagle.tracing.Trace.idOption)

  private def acquire[F[_] : Sync : Env, Thrift[_[_]] : HigherKindedToMethodPerEndpoint](addr: SocketAddress[IpAddress],
                                                                                         label: String,
                                                                                         iface: Thrift[Future]): F[ListeningServer] =
    ZipkinTracer(label)
      .flatMap { tracer =>
        Sync[F].delay {
          Thrift
            .server
            .withLabel(label)
            .withTracer(tracer)
            .serveIface(addr.toInetSocketAddress, iface.toMethodPerEndpoint)
        }
      }

  private def release[F[_] : Async](s: ListeningServer): F[Unit] =
    liftFuture(Sync[F].delay(s.close()))

  private class UnsafeInstrumentationToFuture[F[_] : MonadCancelThrow, Thrift[_[_]]](dispatcher: Dispatcher[F],
                                                                                     entryPoint: EntryPoint[F],
                                                                                     spanOptions: Span.Options,
                                                                                    )
                                                                                    (implicit ec: ExecutionContext,
                                                                                     LocalSpan: Local[F, Span[F]]) extends (Instrumentation[F, *] ~> Future) {
    override def apply[A](instrumentation: Instrumentation[F, A]): Future[A] =
      currentTraceId().flatMap { maybeTraceId =>
        val p = Promise[A]()

        val fa = entryPoint.continueOrElseRoot(
            name = s"${instrumentation.algebraName}.${instrumentation.methodName}",
            kernel = maybeTraceId
              .map(ZipkinKernel.asKernel)
              .getOrElse(Kernel(Map.empty)),
            options = spanOptions
          )
          .use(Local[F, Span[F]].scope(instrumentation.value))

        dispatcher.unsafeToFuture(fa)
          .onComplete {
            case Success(a) => p.setValue(a)
            case Failure(ex) => p.setException(ex)
          }

        p
      }
  }

}
